---
title: JVM-类加载器
status: Done
Tags:
  - Java
  - JVM
---

---

## 前置

[JVM-08.JVM类加载过程](JVM-08.JVM类加载过程.md)

Java 中的所有类，都需要由类加载装载到 JVM 

## 类与类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

通俗的讲就是比较两个类是否"**相等**"，只有在**这两个类是由同一个类加载器加载的前提下才有意义**，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，**只要加载它们的类加载器不同，那这两个类就必定不相等**。

上文所指的"**相等**"具体有哪些：

- 类的Class对象的 equals() 方法
- isAssignableFrom() 方法
- isInstance() 方法
- instanceof

## 双亲委派模型

![[双亲委派模型.png]]


### 启动类加载器

- 加载目录：$JAVA_HOME/lib 或被 -Xbootclasspath 参数指定的路径
- 类库的文件名是固定的，例如：rt.jar、tools.jar，名字不符合的即时放在目录中也不会加载
- 启动类加载器无法被直接引用，如果在自定义加载器时，需要把加载请求委派到引导类加载器去处理，直接用 null 代替即可

### 扩展类加载器

- sun.misc.Launcher$ExtClassLoader
- 加载目录：$JAVA_HOME/lib/ext 或被 java.ext.dirs 系统变量所指定的路径中的所有类库

### 应用程序类加载器

- sun.misc.Launcher$AppClassLoader
- ClassLoader#getSystemClassLoader()
- 负责加载用户类路径(ClassPath)上的所有类库
- 可以在代码中使用

### 工作过程

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

这样做的好处是

- Java中的类随着它的的类加载器一起具备了一种带有优先级的层次关系；
- 可以保证类在各种类加载器环境中都是同一个类；
    - 例如 java.lang.Object , 它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此 Object 类在程序的各个类加载器环境中都是同一个类。自己编写一个与 rt.jar 类库中已有类重名的 java 类，可以正常编译，但无法被加载运行。

## 参考资料

- 《深入理解Java虚拟机》章节7.4

