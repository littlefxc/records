

---
title: MySQL事务相关
Tags:
  - mysql
---

# 1. 概述

本文重新梳理一些关于 MySQL 事务相关的概念，主要包括：事务隔离引发的问题和事务隔离的级别。

<!-- more -->

# 2 什么是数据库事务？

我觉得首先在讨论事务隔离之前，首先复习一下事务的基本概念。

数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 ——[百度百科](https://baike.baidu.com/item/数据库事务/9744607)

简单来说，假如你有2条sql要执行，如果放到一个事务里，要么2个sql都执行成功，要么都失败。都执行成功了就提交事务，有一个失败了就回滚，（在一个事务里）不存在一个成功一个失败。



# 3 事务的 ACID 原则 ？

- 原子性：事务的所有操作要么全部成功，要么全部回滚。
- 一致性：总是从一个一致性的状态转换到另一个一致性的状态。
- 持久性：已被提交的事务对数据库的修改应该永久保存在数据库中。
- 隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行

# 4 事务隔离引发的问题？

- 脏读
- 不可重复读
- 幻读

以上三个场景都是出现在多个事务同时执行时的场景。

## 4.1 什么是脏读（Read Uncommitted）？

通俗的讲，**一个事务在处理过程中读取了另外一个事务未提交的数据**，万一你没提交数据就回滚了，我读到的这个数据你说脏不脏。

举例：

> ```text
> 事务1： A给B转账500，但是事务未提交。
> 事务2： B查看了账户，发现A转过来500，本来只转300过来就好，发现多转了200，心里美滋滋。。。
> 事务1： A及时发现多转了200，修改了转300，提交事务。
> ```

### **怎么解决？**

设置隔离级别为 `Read Committed`

## 4.2 什么是不可重复读（Non-repeatable Read）?

通俗的讲，**一个事务范围内，多次查询某个数据，却得到不同的结果**。

举例：

> ```text
> 事务1：B去买东西，卡里有500块钱，消费100，还没提交事务。
> 事务2：B的老婆把B的500块钱转出去了，已提交事务。
> 事务1：B此时提交事务，支付不了。再次读取发现卡里没钱支付。
> ```

### **怎么解决？**

设置隔离级别为 `Repeatable read`

### **与脏读的区别？**

脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，这实际上是违反了事务的一致性原则

## 4.3 什么是幻读（Phantom Read）？

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。

在Repeatable Read隔离级别下，一个事务可能会遇到幻读(Phantom Read)的问题。
事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。

举例：

> ```text
> 事务1：B的老婆查看B的卡消费记录，目前共消费了500元。
> 事务2：B此时刚在外面请朋友吃完饭，付款了100，事务已提交。
> B的老婆决定把账单打印出来，晚上跟B对账，却发现打印出来的消费为600元。她刚才明明看到是500，怎么是600，难道是幻觉？
> ```

### 怎么解决？

可以将隔离级别设置为最高级的`Serializable`，这时候事务都是按照顺序执行的，脏读、幻读、不可重复度都可以避免，但是性能很差。

# 5 事务的隔离级别

为了解决以上的问题，主流的关系型数据库都会提供四种事务的隔离级别。事务隔离级别从低到高分别是：`读未提交`、`读已提交`、`可重复读`、`串行化`。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。

- **READ-UNCOMMITTED(读取未提交)**： 

  最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

- **READ-COMMITTED(读取已提交)**： 

  允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

- **REPEATABLE-READ(可重复读)**：

  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

- **SERIALIZABLE(可串行化)**： 

  最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

所以在设置数据库的事务隔离级别时需要做一下权衡，**MySQL默认是`REPEATABLE-READ`的级别，Oracle 默认采用的 `READ-COMMITTED`隔离级别**。

## 5.1 如何查看当前MySQL 的隔离级别？

```sql
select @@transaction_isolation;
或
show variables like 'transaction_isolation'
```

![image-20210914160820416](https://img-blog.csdnimg.cn/img_convert/7359f4ae271ca3806aebd3e6b25a7826.png)



# 6 事务的隔离机制的实现？

## 6.1 MVCC 概念介绍

前面讲了这么多的事务隔离相关的东西，但还是不懂事务隔离的原理？

直到我查看了《高性能 MySQL》的这一章节：

> 1.4 多版本并发控制
>
> MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。不仅是MySQL，包括 Oracle、PostgreSQL 等其它数据库系统也都实现了MVCC，但各自的实现机制不尽相同，因为 MVCC 没有一个统一的实现标准。
>
> **<font color=red>可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行</font>**。
>
> MVCC 的实现，是通过保存数据在某个时间得按的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
>
> InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在 `REPEATABLE READ` 隔离级别下，MVCC 具体是如何操作的。
>
> SELECT 
>
> ​         InnoDB 会根据以下两个条件检查版本号：
>
> ​				a. InnoDB 只查找版本早于当前事务版本的数据行（也就是说，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取行，要么是事务开始前已经存在的，要么是事务自身插入或者修改过的。
>
> ​				b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
>
> ​		只有符合上述两个条件的记录，才能返回作为查询结果。
>
> ​		INSERT
>
> ​				InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。
>
> ​		DELETE
>
> ​				InnoDB 为删除的每一行保存当前系统版本号座位行删除标识
>
> ​		UPDATE
>
> ​				InnoDB 为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行到原来的行作为删除标识
>
> 保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。
>
> MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。 

